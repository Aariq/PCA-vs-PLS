---
title: "Re-analysis of Muir et al. data"
author: "Eric R. Scott"
output: 
  html_notebook:
    code_folding: hide
    number_sections: yes
    theme: paper
---

```{r message=FALSE, warning=FALSE}
library(tidyverse)
library(here)
library(ropls)
library(glue)
library(colorspace)
library(ggrepel)
source(here("R", "ropls_helpers.R"))
source(here("R", "ropls_plots.R"))
```

# Read in Data

I'm going to remove the outlier species, *S. juglandifolium* for the sake of this analysis

```{r}
tomato <- read_rds(here("data", "tomatoes.rds"))

#remove S.juglandifolium
tomato.filtered <-
  tomato %>% 
  filter(Spe != "jug") %>% 
  mutate(temp = temp * 0.1) %>% 
  filter(complete.cases(.))
```


# PCA

```{r}
X <-tomato.filtered %>% dplyr::select(lma.leaflet:Rdark)
tom.pca <- opls(X, plotL = FALSE)
```

## Score plot:

```{r}
tom.pca.data <- get_plotdata(tom.pca)

ggplot(tom.pca.data$scores, aes(x = p1, y = p2)) +
  geom_point(aes(fill = tomato.filtered$precip), shape = 21, size = 2) +
  scale_fill_viridis_c() +
  labs(x = glue("PC1 ({tom.pca.data$axis_stats[1,1] * 100}%)"),
       y = glue("PC2 ({tom.pca.data$axis_stats[2,1] * 100}%)"),
       fill = "Annual Precipitation (mm)") +
  theme_bw()
```

## Correlation plot

PC1 is the leaf economics spectrum

```{r}
pca.scores <- get_scores(tom.pca)

pca.data <-
  tom.pca@suppLs$xModelMN %>%
  as_tibble()

pca.cor.dat <-
  cor(pca.scores[2:3], pca.data, use = "pairwise.complete.obs") %>%
    t() %>%
    as_tibble(rownames = "variable") %>% 
  rowwise() %>% 
  mutate(distance = sqrt(sum((c(p1, p2) - c(0, 0))^2))) %>% 
  ungroup %>% 
  mutate(t = distance * sqrt((65-2)/(1-distance^2))) %>% 
  mutate(p.dist = pt(t, df = 65-2, lower.tail = FALSE)) %>% 
  mutate(p.adj = p.adjust(p.dist, method = "bonf"))
# pca.cor.dat
```
```{r}
pca.cor.plot <-
  ggplot(pca.cor.dat) +
  geom_segment(aes(x = 0, y = 0, xend = p1, yend = p2),
               arrow = arrow(length = unit(0.15, "cm"))) +
  geom_label_repel(aes(x = p1, y = p2, label = variable),
                   segment.alpha = 0.6, direction = "y", size = 2.7, 
                   min.segment.length = 0, force = 3) +
  theme_bw() +
  labs(x = "Correlation to PC1",
       y = "Correlation to PC2")
pca.cor.plot
```
## Biplot

Combines scores and loadings. I'm specifically making a *column-principal biplot* where the scores are in standard coordinates (sums of squares = 1 on each axis) and the loadings are in principal coordinates (sums of squares = variance explained by that axis).  This is according to

Greenacre, M. & Primicerio, R. (2013) Ch12. Principal Component Analysis. In *Multivariate Analysis of Ecological Data*. pp. 151â€“161.


```{r}
scaled_loadings <- get_loadings(tom.pca) %>% 
  mutate(p1 = ss_scale(p1, tom.pca.data$axis_stats$R2X[1]),
         p2 = ss_scale(p2, tom.pca.data$axis_stats$R2X[2])) %>% 
  mutate(Variable = case_when(
    Variable == "lma.leaflet" ~ "LMA",
    Variable == "thick.vile" ~ "Thickness",
    Variable == "ldmc" ~ "LDMC",
    Variable == "wue" ~ "WUE",
    TRUE ~ Variable
  ))

scaled_scores <- get_scores(tom.pca) %>% 
  mutate_if(is.numeric, ss_scale) %>% 
  add_column(precip = tomato.filtered$precip)

pca.biplot <- 
  ggplot(scaled_scores) +
  geom_point(aes(x = p1, y = p2, fill = precip),
             shape = 21, size = 2) +
  scale_fill_viridis_c() +
  geom_segment(data = scaled_loadings, 
               aes(x = 0, y = 0, xend = p1, yend = p2),
               alpha = 0.6,
               arrow = arrow(length = unit(0.15, "cm"))) +
  geom_label_repel(data = scaled_loadings, 
                   aes(x = p1, y = p2, label = Variable),
                   segment.alpha = 0.6, direction = "y", size = 2.7, 
                   min.segment.length = 5, force = 10) +
  labs(x = glue("Principal Component 1 ({tom.pca.data$axis_stats[1,1] * 100}%)"),
       y = glue("Principal Component 2 ({tom.pca.data$axis_stats[2,1] * 100}%)"),
       fill = "Annual Precipitation (mm)",
       title = "Principal Components Analysis (PCA)") +
  theme_bw()
pca.biplot
```


# PCA regression

Precipitation, is not significantly related to PC1 (i.e. the LES)

```{r}
pcr.df2 <-
  tom.pca.data$scores %>% 
  add_column(temp = tomato.filtered$temp, precip = tomato.filtered$precip)
```

```{r}
m0 <- lm(precip ~ 1, data = pcr.df2)
m1 <- lm(precip ~ p1, data = pcr.df2)
m2 <- lm(precip ~ p2, data = pcr.df2)
m3 <- lm(precip ~ p1 + p2, data = pcr.df2)

car::Anova(m3)
lrtest(m0, m1)
summary(m1)
lrtest(m0, m2)
summary(m2)
lrtest(m0, m3)
summary(m3)
```


# PLSR

Precipitation is significantly related to leaf traits.  The predictive axes explain very little of the variation in the leaf traits (`R2X(cum)`), but a significant amount of variation in precipitation (`R2Y(cum)` and `pR2Y` and `pQ2`).  `Q2(cum)` is not much lower than `R2Y(cum)` indicating an absence of overfitting or a predictive power similar to the explanatory power.

```{r}
tom.pls <- 
  opls(X, tomato.filtered$precip, fig.pdfC = "none")
#produces a single component model.  I will "force" two predictive axes for the sake of plotting.
tom.pls <- 
  opls(X, tomato.filtered$precip, fig.pdfC = "none", predI = 2, permI = 1000)

get_modelinfo(tom.pls)
```

## PLSR bi-plot

```{r}
tom.pls.data <- get_modelinfo(tom.pls)
scaled_loadings <- get_loadings(tom.pls) %>% 
  mutate(p1 = ss_scale(p1, tom.pls.data$axis_stats$R2X[1]),
         p2 = ss_scale(p2, tom.pls.data$axis_stats$R2X[2])) %>% 
    mutate(Variable = case_when(
    Variable == "lma.leaflet" ~ "LMA",
    Variable == "thick.vile" ~ "Thickness",
    Variable == "ldmc" ~ "LDMC",
    Variable == "wue" ~ "WUE",
    TRUE ~ Variable
  ))

scaled_scores <- get_scores(tom.pls) %>% 
  mutate_if(is.numeric, ss_scale) %>% 
  add_column(precip = tomato.filtered$precip)
  
pls.biplot <- 
  ggplot(scaled_scores) +
  geom_point(aes(x = p1, y = p2, fill = precip),
             shape = 21, size = 2) +
  scale_fill_viridis_c() +
  geom_segment(data = scaled_loadings,
               aes(x = 0, y = 0, xend = p1, yend = p2),
               alpha = 0.6,
               arrow = arrow(length = unit(0.15, "cm"))) +
  geom_label_repel(data = scaled_loadings,
                   aes(x = p1, y = p2, label = Variable),
                   segment.alpha = 0.6, direction = "y", size = 2.7, 
                   min.segment.length = 5, force = 10) +
  labs(x = glue("Predictive Component 1 ({tom.pls.data$axis_stats[1,1] * 100}%)"),
       y = glue("Predictive Component 2 ({tom.pls.data$axis_stats[2,1] * 100}%)"),
       fill = "Annual Precipitation (mm)",
       title = "Partial Least Squares (PLS) Regression") +
  theme_bw()
pls.biplot
```
## Compose and output plot

```{r}
library(patchwork)
patchwork <- 
  pca.biplot + pls.biplot +
  plot_layout(guides = "collect") +
  plot_annotation(tag_levels = "A") &
  theme(panel.grid = element_blank())

patchwork[[1]] <- patchwork[[1]] + theme(legend.position = "none")
patchwork
ggsave(here("out", "muir-biplots.png"), width = 10, height = 4)
```


# Compare Loadings

Table of loadings from the first PCA and PLS axes.

```{r}
pls.loadings <- get_loadings(tom.pls) %>% select(Variable, PLS = p1)
pca.loadings <- get_loadings(tom.pca) %>% select(Variable, PCA = p1)

loading.table <-
  full_join(pca.loadings, pls.loadings) %>%
  mutate_if(is.numeric, ~round(., 3))

loading.table
write_csv(loading.table, here("out", "muir loading table.csv"))
```
# Correlations

Make a table of axis correlations instead of loadings.  I think these are mathematically related.

According to Cadima & Joliffe 1995:

$$
\rho_{ij} = a_{ij}\bigg(\frac{\lambda_i}{s_{ij}}\bigg)^{1/2}
$$

Where $a_{ij}$ is the loading for the $i$th variable in the $j$the PC, $\lambda$ is the eigenvalue of the PC, and $s_{ij}$ is the variance of the variable, which should be 1 because I scaled everything to unit variance.  So, it simplifies to:

$$
\rho_{ij} = a_{ij}\times \sqrt{\lambda_i}
$$
See also: https://stats.stackexchange.com/questions/143905/loadings-vs-eigenvectors-in-pca-when-to-use-one-or-another

But, I'm just going to calculate this as the correlation between the scores and the data.


```{r}
pc1 <- get_scores(tom.pca)$p1
p1 <- get_scores(tom.pls)$p1

cor.table <- 
  tibble(Variable = loading.table$Variable,
       PCA = map_dbl(X, ~cor(.x, pc1)),
       PLS = map_dbl(X, ~cor(.x, p1)))
write_csv(cor.table, here("out", "muir correlation table.csv"))
```
